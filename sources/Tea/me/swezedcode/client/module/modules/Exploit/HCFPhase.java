package me.swezedcode.client.module.modules.Exploit;

import org.lwjgl.input.Keyboard;

import com.darkmagician6.eventapi.EventListener;
import com.google.common.eventbus.EventBus;

import me.swezedcode.client.module.ModCategory;
import me.swezedcode.client.module.Module;
import me.swezedcode.client.utils.events.BoundingBoxEvent;
import me.swezedcode.client.utils.events.EventBBSet;
import me.swezedcode.client.utils.events.EventEntityCollision;
import me.swezedcode.client.utils.events.EventMotion;
import me.swezedcode.client.utils.events.EventPreMotionUpdates;
import net.minecraft.block.Block;
import net.minecraft.block.BlockAir;
import net.minecraft.block.BlockHopper;
import net.minecraft.util.AxisAlignedBB;
import net.minecraft.util.BlockPos;
import net.minecraft.util.MathHelper;

public class HCFPhase extends Module {

	public HCFPhase() {
		super("HCFPhase", Keyboard.KEY_NONE, 0xFFF0C059, ModCategory.Exploit);
	}

	private double distance = 1.5D;

	@EventListener
	private void onUpdate(EventMotion event) {
		if (event.getType().equals(event.getType().PRE)) {
			if ((isInsideBlock()) && (mc.thePlayer.isSneaking())) {
				float yaw = mc.thePlayer.rotationYaw;
				mc.thePlayer.boundingBox.offsetAndUpdate(this.distance * Math.cos(Math.toRadians(yaw + 90.0F)), 0.0D,
						this.distance * Math.sin(Math.toRadians(yaw + 90.0F)));
			}
		}
	}

	@EventListener
	private void onSetBoundingbox(EventEntityCollision event) {
		if ((event.getBoundingBox() != null) && (event.getBoundingBox().maxY > mc.thePlayer.boundingBox.minY)
				&& (mc.thePlayer.isSneaking())) {
			event.setBoundingBox(null);
		}
	}

	private boolean isInsideBlock() {
		for (int x = MathHelper.floor_double(mc.thePlayer.boundingBox.minX); x < MathHelper
				.floor_double(mc.thePlayer.boundingBox.maxX) + 1; x++) {
			for (int y = MathHelper.floor_double(mc.thePlayer.boundingBox.minY); y < MathHelper
					.floor_double(mc.thePlayer.boundingBox.maxY) + 1; y++) {
				for (int z = MathHelper.floor_double(mc.thePlayer.boundingBox.minZ); z < MathHelper
						.floor_double(mc.thePlayer.boundingBox.maxZ) + 1; z++) {
					Block block = mc.theWorld.getBlockState(new BlockPos(x, y, z)).getBlock();
					if ((block != null) && (!(block instanceof BlockAir))) {
						AxisAlignedBB boundingBox = block.getCollisionBoundingBox(mc.theWorld, new BlockPos(x, y, z),
								mc.theWorld.getBlockState(new BlockPos(x, y, z)));
						if ((block instanceof BlockHopper)) {
							boundingBox = new AxisAlignedBB(x, y, z, x + 1, y + 1, z + 1);
						}
						if (boundingBox != null) {
							if (mc.thePlayer.boundingBox.intersectsWith(boundingBox)) {
								return true;
							}
						}
					}
				}
			}
		}
		return false;
	}
}
