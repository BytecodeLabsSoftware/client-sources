package cc.slack.features.modules.impl.exploit;

import cc.slack.events.impl.player.MoveEvent;
import cc.slack.features.modules.api.Category;
import cc.slack.features.modules.api.Module;
import cc.slack.features.modules.api.ModuleInfo;
import cc.slack.features.modules.api.settings.Value;
import cc.slack.features.modules.api.settings.impl.ModeValue;
import cc.slack.features.modules.api.settings.impl.NumberValue;
import cc.slack.utils.client.mc;
import io.github.nevalackin.radbus.Listen;

@ModuleInfo(
   name = "Phase",
   category = Category.EXPLOIT
)
public class Phase extends Module {
   private final ModeValue<String> mode = new ModeValue(new String[]{"Clip"});
   private final NumberValue<Double> offset = new NumberValue("Offset", 1.0D, 0.1D, 8.0D, 0.1D);
   boolean insideBlock;

   public Phase() {
      this.addSettings(new Value[]{this.mode, this.offset});
   }

   public void onEnable() {
      this.insideBlock = false;
   }

   @Listen
   public void onMove(MoveEvent Event) {
      String var2 = ((String)this.mode.getValue()).toLowerCase();
      byte var3 = -1;
      switch(var2.hashCode()) {
      case 0:
         if (var2.equals("")) {
            var3 = 1;
         }
         break;
      case 3056464:
         if (var2.equals("clip")) {
            var3 = 0;
         }
      }

      switch(var3) {
      case 0:
         double yaw = Math.toRadians((double)mc.getPlayer().rotationYaw);
         if (mc.getPlayer().isCollidedHorizontally) {
            this.insideBlock = true;
            mc.getPlayer().setPosition(mc.getPlayer().posX + -Math.sin(yaw) * 0.005D, mc.getPlayer().posY, mc.getPlayer().posZ + Math.cos(yaw) * 0.005D);
         } else if (this.insideBlock) {
            mc.getPlayer().setPosition(mc.getPlayer().posX + -Math.sin(yaw) * (Double)this.offset.getValue(), mc.getPlayer().posY, mc.getPlayer().posZ + Math.cos(yaw) * (Double)this.offset.getValue());
            this.insideBlock = false;
         }
      case 1:
      default:
      }
   }
}
