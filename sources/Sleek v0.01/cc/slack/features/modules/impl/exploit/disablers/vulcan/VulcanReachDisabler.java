package cc.slack.features.modules.impl.exploit.disablers.vulcan;

import cc.slack.events.impl.network.PacketEvent;
import cc.slack.events.impl.player.UpdateEvent;
import cc.slack.events.impl.player.WorldEvent;
import cc.slack.features.modules.impl.exploit.disablers.IDisabler;
import cc.slack.utils.client.mc;
import cc.slack.utils.other.PrintUtil;
import io.github.nevalackin.radbus.Listen;
import java.util.LinkedList;
import java.util.Queue;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.C00PacketKeepAlive;
import net.minecraft.network.play.client.C0FPacketConfirmTransaction;

public class VulcanReachDisabler implements IDisabler {
   int ticks = 0;
   boolean shouldSend = false;
   Queue<Packet> packets = new LinkedList();

   public void onDisable() {
      mc.getNetHandler().getNetworkManager().channel.writeAndFlush(this.packets);
      this.packets.clear();
   }

   @Listen
   public void onWorld(WorldEvent event) {
      PrintUtil.print("XD");
      this.packets.clear();
      this.ticks = 0;
   }

   @Listen
   public void onUpdate(UpdateEvent event) {
      if (this.ticks <= 100) {
         ++this.ticks;
      }

   }

   @Listen
   public void onPacket(PacketEvent event) {
      Packet packet = event.getPacket();
      if (this.ticks > 100 && mc.getPlayer().ticksExisted % 60 == 0) {
         if (mc.getCurrentScreen() == null) {
            if (packet instanceof C00PacketKeepAlive || packet instanceof C0FPacketConfirmTransaction) {
               event.cancel();
               this.packets.add(packet);
               this.shouldSend = true;
            }
         } else {
            this.packets.clear();
         }
      }

      if (mc.getPlayer().ticksExisted % 20 == 0 && this.shouldSend) {
         mc.getNetHandler().getNetworkManager().channel.writeAndFlush(this.packets);
         this.shouldSend = false;
      }

   }

   public String toString() {
      return "Vulcan Reach";
   }
}
