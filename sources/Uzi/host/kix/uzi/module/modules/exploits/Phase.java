package host.kix.uzi.module.modules.exploits;

import com.darkmagician6.eventapi.SubscribeEvent;

import com.darkmagician6.eventapi.types.EventType;
import host.kix.uzi.events.BoundingBoxEvent;
import host.kix.uzi.events.MotionEvent;
import host.kix.uzi.events.UpdateEvent;
import host.kix.uzi.module.Module;
import host.kix.uzi.utilities.value.Value;
import net.minecraft.block.Block;
import net.minecraft.block.BlockAir;
import net.minecraft.block.BlockHopper;
import net.minecraft.network.play.client.C03PacketPlayer;
import net.minecraft.util.AxisAlignedBB;
import net.minecraft.util.BlockPos;
import net.minecraft.util.MathHelper;

/**
 * Created by k1x on 4/23/17.
 */
public class Phase extends Module {

    public static Value<Mode> mode = new Value<Mode>("Mode", Mode.ARIS);
    private boolean collided = false;
    private Value<Double> boost = new Value<Double>("boost", 0.6, 0.1, 100.0);

    public Phase() {
        super("Phase", 0, Category.EXPLOITS);
        add(boost);
        add(mode);
    }

    public static boolean isInsideBlock() {
        for (int x = MathHelper.floor_double(mc.thePlayer.boundingBox.minX); x < MathHelper.floor_double(mc.thePlayer.boundingBox.maxX) + 1; x++) {
            for (int y = MathHelper.floor_double(mc.thePlayer.boundingBox.minY); y < MathHelper.floor_double(mc.thePlayer.boundingBox.maxY) + 1; y++) {
                for (int z = MathHelper.floor_double(mc.thePlayer.boundingBox.minZ); z < MathHelper.floor_double(mc.thePlayer.boundingBox.maxZ) + 1; z++) {
                    Block block = mc.theWorld.getBlockState(new BlockPos(x, y, z)).getBlock();
                    if ((block != null) && (!(block instanceof BlockAir))) {
                        AxisAlignedBB boundingBox = block.getCollisionBoundingBox(mc.theWorld, new BlockPos(x, y, z), mc.theWorld.getBlockState(new BlockPos(x, y, z)));
                        if ((block instanceof BlockHopper)) {
                            boundingBox = new AxisAlignedBB(x, y, z, x + 1, y + 1, z + 1);
                        }
                        if ((boundingBox != null) && (mc.thePlayer.boundingBox.intersectsWith(boundingBox))) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }

    @SubscribeEvent
    public void motion(MotionEvent event) {
        switch (mode.getValue()) {
            case ARIS:
                if ((isInsideBlock()) && (mc.thePlayer.isSneaking())) {
                    float yaw = mc.thePlayer.rotationYaw;
                    mc.thePlayer.boundingBox.offsetAndUpdate(this.boost.getValue() * Math.cos(Math.toRadians(yaw + 90.0F)), 0.0D, this.boost.getValue() * Math.sin(Math.toRadians(yaw + 90.0F)));
                }
                break;
        }
    }

    @SubscribeEvent
    public void update(UpdateEvent event) {
        if (mc.thePlayer.isCollidedHorizontally && event.getType() == EventType.POST) {
            double x = -MathHelper.sin(mc.thePlayer.getDirection()) * boost.getValue(),
                    z = MathHelper.cos(mc.thePlayer.getDirection()) * boost.getValue();
            if (mode.getValue() == Mode.VELT) {
                position(mc.thePlayer.posX + x, mc.thePlayer.posY,
                        mc.thePlayer.posZ + z, false);
                position(mc.thePlayer.posX + x, mc.theWorld.getActualHeight(),
                        mc.thePlayer.posZ + z, true);
                mc.thePlayer.setPosition(mc.thePlayer.posX + x, mc.thePlayer.posY,
                        mc.thePlayer.posZ + z);
            }
        }
    }

    @SubscribeEvent
    public void boundingBox(BoundingBoxEvent event) {
        switch (mode.getValue()) {
            case ARIS:
                if ((event.getBoundingBox() != null) && (event.getBoundingBox().maxY > mc.thePlayer.boundingBox.minY) && (mc.thePlayer.isSneaking())) {
                    event.setBoundingBox(null);
                }
                break;
            case VELT:
                break;
        }
    }

    private void position(double x, double y, double z, boolean grounded) {
        mc.thePlayer.sendQueue.addToSendQueue(new C03PacketPlayer.C04PacketPlayerPosition(x, y, z, grounded));
    }

    public enum Mode {
        ARIS,
        VELT
    }

}
