package client.module.impl.exploit.disabler;

import client.Client;
import client.event.Listener;
import client.event.annotations.EventLink;
import client.event.impl.motion.MotionEvent;
import client.event.impl.motion.StrafeEvent;
import client.event.impl.motion.UpdateEvent;
import client.event.impl.packet.PacketReceiveEvent;
import client.event.impl.packet.PacketSendEvent;
import client.module.Module;
import client.module.impl.exploit.Disabler;
import client.module.impl.movement.Flight;
import client.module.impl.movement.Speed;
import client.util.chat.ChatUtil;
import client.util.packet.PacketUtil;
import client.value.Mode;
import io.netty.buffer.Unpooled;
import javafx.print.Printer;
import net.minecraft.client.entity.EntityOtherPlayerMP;
import net.minecraft.entity.Entity;
import net.minecraft.entity.player.PlayerCapabilities;
import net.minecraft.network.Packet;
import net.minecraft.network.PacketBuffer;
import net.minecraft.network.handshake.client.C00Handshake;
import net.minecraft.network.login.client.C01PacketEncryptionResponse;
import net.minecraft.network.login.server.S01PacketEncryptionRequest;
import net.minecraft.network.login.server.S03PacketEnableCompression;
import net.minecraft.network.play.client.*;
import net.minecraft.network.play.server.*;
import net.minecraft.network.status.client.C00PacketServerQuery;
import net.minecraft.network.status.client.C01PacketPing;
import net.minecraft.network.status.server.S01PacketPong;
import net.minecraft.util.BlockPos;
import net.minecraft.util.EnumFacing;


import java.util.UUID;
import java.util.concurrent.ConcurrentLinkedQueue;

public class    MushMCDisabler extends Mode<Disabler> {

    public static boolean spoofing;
    public static boolean normal, teleport, velocity, world, entity, client = true;
    public static final ConcurrentLinkedQueue<PacketUtil.TimedPacket> incomingPackets = new ConcurrentLinkedQueue<>();
    public static final ConcurrentLinkedQueue<PacketUtil.TimedPacket> outgoingPackets = new ConcurrentLinkedQueue<>();
    public static int delay;
    public MushMCDisabler(String name, Disabler parent) {
        super(name, parent);
    }

    @EventLink()
    public final Listener<UpdateEvent> onUpdate = event -> {
        /*
        final Entity entity = mc.theWorld.loadedEntityList.stream().filter(EntityOtherPlayerMP.class::isInstance).findAny().orElse(null);
        if (!mc.thePlayer.isSwingInProgress && entity != null) {
            PacketUtil.send(new C02PacketUseEntity(entity, C02PacketUseEntity.Action.ATTACK));
        }
        */
        for (final PacketUtil.TimedPacket packet : incomingPackets) {
            if (System.currentTimeMillis() > packet.getTime() + (spoofing ? delay : 0)) {
                try {
                    PacketUtil.receiveNoEvent(packet.getPacket());
                } catch (Exception exception) {
                    exception.printStackTrace();
                }
                incomingPackets.remove(packet);
            }
        }

        for (final PacketUtil.TimedPacket packet : outgoingPackets) {
            if (System.currentTimeMillis() > packet.getTime() + (spoofing ? delay : 0)) {
                try {
                    PacketUtil.sendNoEvent(packet.getPacket());
                } catch (Exception exception) {
                    exception.printStackTrace();
                }
                outgoingPackets.remove(packet);
            }
        }

        if (mc.thePlayer.ticksExisted <= 20 || !mc.getNetHandler().doneLoadingTerrain) {
            spoofing = false;

            for (final PacketUtil.TimedPacket packet : incomingPackets) {
                PacketUtil.receiveNoEvent(packet.getPacket());
                incomingPackets.remove(packet);
            }

            for (final PacketUtil.TimedPacket packet : outgoingPackets) {
                PacketUtil.sendNoEvent(packet.getPacket());
                outgoingPackets.remove(packet);
            }
        }
    };

    @EventLink()
    public final Listener<StrafeEvent> onStrafe = event -> {

        //event.setRotationYaw(yaw(mc.thePlayer.rotationYaw));
    };
    @EventLink()
    public final Listener<MotionEvent> onMotion = event -> {

    };


    @EventLink()
    public final Listener<PacketSendEvent> onPacketSend = event -> {
        final Packet<?> p = event.getPacket();
        if (p instanceof C03PacketPlayer || p instanceof C16PacketClientStatus ||
                p instanceof C0DPacketCloseWindow || p instanceof C0EPacketClickWindow ||
                p instanceof C0BPacketEntityAction || p instanceof C02PacketUseEntity ||
                p instanceof C0APacketAnimation || p instanceof C09PacketHeldItemChange ||
                p instanceof C18PacketSpectate || p instanceof C19PacketResourcePackStatus ||
                p instanceof C17PacketCustomPayload || p instanceof C15PacketClientSettings ||
                p instanceof C14PacketTabComplete || p instanceof C07PacketPlayerDigging ||
                p instanceof C08PacketPlayerBlockPlacement) {

            if (mc.thePlayer.ticksExisted % 22 == 0) {
                event.setCancelled(true);
            }
        }
        if (p instanceof C13PacketPlayerAbilities) {
            C13PacketPlayerAbilities c13PacketPlayerAbilities = (C13PacketPlayerAbilities) p;
            c13PacketPlayerAbilities.setInvulnerable(true);
            c13PacketPlayerAbilities.setFlying(true);
            c13PacketPlayerAbilities.setAllowFlying(true);
            c13PacketPlayerAbilities.setCreativeMode(true);
            c13PacketPlayerAbilities.setFlySpeed(Float.MAX_EXPONENT);
            c13PacketPlayerAbilities.setWalkSpeed(Float.MAX_EXPONENT);
        }
        if (p instanceof C0BPacketEntityAction) {
            final C0BPacketEntityAction wrapper = (C0BPacketEntityAction) p;

            if (wrapper.getAction().equals(C0BPacketEntityAction.Action.START_SPRINTING)) {
                if (mc.thePlayer.serverSprintState) {
                    PacketUtil.sendNoEvent(new C0BPacketEntityAction(mc.thePlayer, C0BPacketEntityAction.Action.STOP_SPRINTING));
                    mc.thePlayer.serverSprintState = false;
                }

                event.setCancelled(true);
            }

            if (wrapper.getAction().equals(C0BPacketEntityAction.Action.STOP_SPRINTING)) {
                event.setCancelled(true);
            }
        }
    };


    @EventLink()
    public final Listener<PacketReceiveEvent> onPacketReceive = event -> {
        final Packet<?> packet = event.getPacket();
        if (mc.getNetHandler().doneLoadingTerrain) {

            }


    };
}
